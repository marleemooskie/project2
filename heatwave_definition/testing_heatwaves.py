'''This script will be used to define heatwaves using the max, EHF, and Pezza definition approaches. For analysis of these, refer to moisture comparison.'''# Import all other packagesimport osimport pandas as pdfrom matplotlib import pyplot as pltos.chdir("/Users/marleeyork/Documents/project2/")from load_data import *os.chdir("/Users/marleeyork/Documents/project2/heatwave_definition")from define_heatwaves import *from overlapping_heatwaves import *import picklefrom collections import Counter# Print all columnspd.set_option('display.max_columns',None)# pd.set_option('display.max_rows',None) # be careful with this, can back up system# Load climatological data# Pausing this for now until we get climatological data across all siteshistorical_data_max = pd.read_csv('/Users/marleeyork/Documents/project2/data/cleaned/historical_data_max.csv')historical_data_min = pd.read_csv('/Users/marleeyork/Documents/project2/data/cleaned/historical_data_min.csv')historical_data_Tmean = pd.read_csv('/Users/marleeyork/Documents/project2/data/cleaned/historical_data_mean.csv')# Add datetime variable for historical datahistorical_data_max["date"] = pd.to_datetime(historical_data_max.date)historical_data_min["date"] = pd.to_datetime(historical_data_min.date)historical_data_Tmean["date"] = pd.to_datetime(historical_data_Tmean.date)# Load in temperature QAQCta = loadAMF(path = "/Users/marleeyork/Documents/project2/data/AMFdataDD",measures=['TIMESTAMP','TA_F','TA_F_QC'])# Chcking what soil water content variables the sites have# Any sites that don't have the first depth, also don't have any of the other depthsswc_measures = ["SWC_F_MDS_1","SWC_F_MDS_2","SWC_F_MDS_3","SWC_F_MDS_4","SWC_F_MDS_5",                "SWC_F_MDS_1_QC","SWC_F_MDS_2_QC","SWC_F_MDS_3_QC","SWC_F_MDS_4_QC",                "SWC_F_MDS_5_QC"]shared_swc = find_shared_variables('/Users/marleeyork/Documents/project2/data/AMFdataDD',swc_measures)# Checking for soil metadatasoil_measures = ["SOIL_TEX_SAND","SOIL_TEX_CLAY","SOIL_TEX_SILT"]shared_soil = find_shared_variables_longfile('/Users/marleeyork/Documents/project2/data/BADM',                                             measures = soil_measures,                                             column = 'VARIABLE',                                             value = 'DATAVALUE',                                             file_type = 'xslx')# Load in AmeriFlux hourly temperature data# For now, we've only done QAQC on the daily values, so this remains the sameAMF_data = df_hourly[['TIMESTAMP_START','TA_F','Site']]# Load in AmeriFlux daily moisture data# We use to load this directly, but now we used cleaned daily values from dfprec_data = loadAMF(path='/Users/marleeyork/Documents/project2/data/AMFdataDD',                    measures=['TIMESTAMP','P_F'])prec_data = prec_data[prec_data['Site'].isin(AMF_data.Site.unique())]swc_data = loadAMF(path='/Users/marleeyork/Documents/project2/data/AMFdataDD',                  measures=['TIMESTAMP','SWC_F_MDS_1'])swc_data = swc_data[swc_data['Site'].isin(AMF_data.Site.unique())]# Make sure all dates are saved as datetimesAMF_data['TIMESTAMP_START'] = pd.to_datetime(AMF_data.TIMESTAMP_START)historical_data['date'] = pd.to_datetime(historical_data.date)#################################################################################                                  MAX                                      #################################################################################'''The following code will fit heatwaves using the maximum approach discussed in Perkins and Alexander. It uses the max temperature for each day and comparesit to a quantile of historical maximum temperature over a certain moving window.I use the parameters most commonly used across the literature (e.g. 15 day movingaverage, 90th quantile, tolerance, etc). The daily max temperatures (not historical ones) are calculated using flux tower data at the hourly interval, thuswe use hourly data as the timeseries input in fit_heatwaves. This is differentfor other approaches!'''# I am going to create a tmax based on the timeseries data that I can use in # replacement of PRISM tmax temporarily as historical data. This will change when # I get the PRISM data for all 45 sites# Initialize empty dictionaryheatwaves = {}for site in swc_data.Site.unique():    # Isolate site of interest in climatological and AMF data    flux_data = AMF_data[AMF_data['Site']==site]    historical_site_data = historical_data_max[historical_data_max['Site']==site]    site_precip = prec_data[prec_data['Site']==site]    site_swc = swc_data[swc_data['Site']==site]        # Fit the heatwave defining function    site_heatwaves = fit_heatwaves(                      flux_dates = flux_data.TIMESTAMP_START,                       flux_temperature = flux_data.TA_F,                       historical_dates = historical_site_data['date'],                       historical_temperature = historical_site_data['hist_TA'],                      quantile_threshold = .97,                      window_length = 15,                      threshold_comparison = 'greater',                      min_heatwave_length = 3,                      tolerance = 1,                      gap_days_window = 8,                      site = site,                      method = "max"                      )        # Getting precipitation conditions    site_heatwave_precip = calculate_moisture(        timeseries_dates = site_precip.TIMESTAMP,        timeseries_moisture = site_precip.P_F,        start_dates = site_heatwaves['start_dates'],        end_dates = site_heatwaves['end_dates']        )    site_heatwave_swc = calculate_moisture(        timeseries_dates = site_swc.TIMESTAMP,        timeseries_moisture = site_swc.SWC_F_MDS_1,        start_dates = site_heatwaves['start_dates'],        end_dates = site_heatwaves['end_dates']        )    # Add heatwaves into a dictionary with their site    heatwaves[site] = site_heatwaves    heatwaves[site]['precip'] = site_heatwave_precip    heatwaves[site]['swc'] = site_heatwave_swc    # Get the hourly temperature quality control flagsta_HH = loadAMF(path="/Users/marleeyork/Documents/project2/data/AMFdata_HH",                 skip = [''],measures=['TIMESTAMP_START','TA_F','TA_F_QC'])# Create a dataframe of the quality flag for each heatwave at each siteheatwaves_qaqc = pd.DataFrame(columns=['start_dates','end_dates','duration','magnitude','QAQC_flag'])for site in list(heatwaves.keys()):    print(site)    # Retrieve the heatwave dictionary for that site    site_heatwave_dictionary = heatwaves[site]    dates = ta_HH[ta_HH['Site']==site].TIMESTAMP_START    TA = ta_HH[ta_HH['Site']==site].TA_F    TA_QAQC = ta_HH[ta_HH['Site']==site].TA_F_QC    # Use function to find if heatwaves have sufficient levels of ERA dowscaled data    site_check = minmax_QAQC_check(site_heatwave_dictionary, dates, TA, TA_QAQC, heatwave_threshold = .5, method='max')    # Add the site onto this dataframe    site_check['Site'] = [site] * site_check.shape[0]    # Concat with the other site dataframes    heatwaves_qaqc = pd.concat([heatwaves_qaqc,site_check])    # Find those invalid heatwavesinvalid_heatwaves = heatwaves_qaqc[heatwaves_qaqc['QAQC_flag']==1]invalid_heatwaves = invalid_heatwaves[['Site','start_dates','end_dates']]invalid_heatwaves.columns = ['Site','start_date','end_date']# Now remove these heatwavesheatwaves = remove_invalid_heatwaves(heatwaves_dictionary = heatwaves, invalid_heatwaves = invalid_heatwaves)# Create a dataframe of all precip conditionsall_precip = pd.DataFrame(columns=['start_date','end_date','moisture_average','moisture_total','Site','Duration'])for site in heatwaves.keys():    # Pull out moisture for the site    site_data = heatwaves[site]['precip']    # Add a site column    site_data['Site'] = [site]*len(site_data)    site_data['Duration'] = heatwaves[site]['summary'].duration    # Concat site data with all other data    all_precip = pd.concat([all_precip,site_data])    # Same for all SWC conditionsall_swc = pd.DataFrame(columns=['start_date','end_date','moisture_average','moisture_total','Site'])for site in heatwaves.keys():    # Pull out moisture for the site    site_data = heatwaves[site]['swc']    # Add a site column    site_data['Site'] = [site]*len(site_data)    # Concat site data with all other data    all_swc = pd.concat([all_swc,site_data])all_swc = all_swc.dropna()# Save the dictionary as a pickleos.chdir("/Users/marleeyork/Documents/project2/data/heatwaves/")with open("heatwaves_max.pkl","wb") as f:    pickle.dump(heatwaves, f)    # Save moisture as a csvall_precip.to_csv("max_precip.csv")all_swc.to_csv("max_swc.csv")# Save invalid heatwaves as wellinvalid_heatwaves.to_csv("invalid_heatwaves_max.csv")#################################################################################                              MEAN                                         ################################################################################## This data is taken from clean_data.py, as it has gone through preprocessingdaily_AMF_TA = df[['date','TA_F','Site']]heatwaves_mean = {}for site in swc_data.Site.unique():    # Isolate site of interest in climatological and AMF data    # Temporarily changing historical data to be the timeseries data so I can get    # a rough estimate of the moisture conditions during the heatwaves    historical_site_data = historical_data_mean[historical_data_mean['Site']==site]    flux_data = daily_AMF_TA[daily_AMF_TA['Site']==site].copy()    site_precip = prec_data[prec_data['Site']==site].copy()    site_swc = swc_data[swc_data['Site']==site].copy()        # Fit the heatwave defining function    site_heatwaves = fit_heatwaves(                      flux_dates = flux_data.date,                       flux_temperature = flux_data.TA_F,                       historical_dates = historical_site_data.date,                      historical_temperature = historical_site_data.hist_TA,                      quantile_threshold = .95,                      window_length = 15,                      threshold_comparison = 'greater',                      min_heatwave_length = 3,                      tolerance = 1,                      gap_days_window = 8,                      site = site,                      method = "mean"                      )        # Getting precipitation conditions    site_heatwave_precip = calculate_moisture(        timeseries_dates = site_precip.TIMESTAMP,        timeseries_moisture = site_precip.P_F,        start_dates = site_heatwaves['start_dates'],        end_dates = site_heatwaves['end_dates']        )        site_heatwave_swc = calculate_moisture(        timeseries_dates = site_swc.TIMESTAMP,        timeseries_moisture = site_swc.SWC_F_MDS_1,        start_dates = site_heatwaves['start_dates'],        end_dates = site_heatwaves['end_dates']        )        # Add heatwaves into a dictionary with their site    heatwaves_mean[site] = site_heatwaves    heatwaves_mean[site]['precip'] = site_heatwave_precip    heatwaves_mean[site]['swc'] = site_heatwave_swc    # Now we quality check the heatwaves# Initialize dataframe to store all heatwave quality checksheatwave_QAQC = pd.DataFrame(columns=['Site','start_date','end_date','QAQC_percentage','heatwave_invalidity'])for site in list(heatwaves_mean.keys()):    # Pull out that sites heatwaves from the heatwave dictionary    site_heatwave_dictionary = heatwaves_mean[site]    # Pull out that sites temperature QAQC dates and values    dates = ta[ta['Site']==site].TIMESTAMP    TA_QAQC = ta[ta['Site']==site].TA_F_QC    # Use the heatwave validity check function to get a dataframe of heatwave validity    site_QAQC = avg_QAQC_check(site_heatwave_dictionary, dates, TA_QAQC,                               QAQC_threshold=.5,heatwave_threshold=.75)    # Add the site onto this dataframe    site_QAQC['Site'] = [site] * site_QAQC.shape[0]    # Concat with the other sites invalidity dataframes    heatwave_QAQC = pd.concat([heatwave_QAQC,site_QAQC])    # Isolate the heatwaves that are flagged as invalidinvalid_heatwaves_mean = heatwave_QAQC[heatwave_QAQC['heatwave_invalidity']==1]invalid_heatwaves_mean = invalid_heatwaves[['Site','start_date','end_date']]# Remove from the heatwave dictionaryheatwaves_mean = remove_invalid_heatwaves(heatwaves_dictionary = heatwaves_mean, invalid_heatwaves = invalid_heatwaves)# Create a dataframe of all precip conditionsall_precip_mean = pd.DataFrame(columns=['start_date','end_date','moisture_average','moisture_total','moisture_variability','Site','Duration'])for site in heatwaves_mean.keys():    # Pull out moisture for the site    site_data = heatwaves_mean[site]['precip']    # Add a site column    site_data['Site'] = [site]*len(site_data)    site_data['Duration'] = heatwaves_mean[site]['summary'].duration    # Concat site data with all other data    all_precip_mean = pd.concat([all_precip_mean,site_data])    # Same for all SWC conditionsall_swc_mean = pd.DataFrame(columns=['start_date','end_date','moisture_average','moisture_total','moisture_variability','Site'])for site in heatwaves_mean.keys():    # Pull out moisture for the site    site_data = heatwaves_mean[site]['swc']    # Add a site column    site_data['Site'] = [site]*len(site_data)    # Concat site data with all other data    all_swc_mean = pd.concat([all_swc_mean,site_data])all_swc_mean = all_swc_mean.dropna()# Save the dictionary as a pickleos.chdir("/Users/marleeyork/Documents/project2/data/heatwaves/")with open("heatwaves_mean.pkl","wb") as f:    pickle.dump(heatwaves_mean, f)    # Save moisture data as csvall_precip_EHF.to_csv("mean_precip.csv")all_swc_EHF.to_csv("mean_swc.csv")# Saving invalid heatwaves as wellinvalid_heatwaves.to_csv("invalid_heatwaves_mean.csv")#################################################################################                               Minimum                                     #################################################################################'''The code below implements the Pezza 2012 heatwave defining approach. This approachuses a 3 day running maximum and minimum temperature threshold to determine heatwaves. '''# Initialize empty dictionaryheatwaves_min = {}for site in swc_data.Site.unique():    flux_data = AMF_data[AMF_data['Site']==site]    # Isolate site of interest in climatological and AMF data    historical_site_data = historical_data_min[historical_data_min['Site']==site]    site_precip = prec_data[prec_data['Site']==site]    site_swc = swc_data[swc_data['Site']==site]        print(f"I'm currently on site {site}.")    # Fit the heatwave defining function    site_heatwaves = fit_heatwaves(        flux_dates = flux_data.TIMESTAMP_START,         flux_temperature = flux_data.TA_F,         historical_dates = historical_data_min.date,         historical_temperature = historical_data_min.hist_TA,        min_heatwave_length = 3,        tolerance=1,        gap_days_window=8,        site = site,        method = 'min'        )        # Getting precipitation conditions    site_heatwave_precip = calculate_moisture(        timeseries_dates = site_precip.TIMESTAMP,        timeseries_moisture = site_precip.P_F,        start_dates = site_heatwaves['start_dates'],        end_dates = site_heatwaves['end_dates']        )        site_heatwave_swc = calculate_moisture(        timeseries_dates = site_swc.TIMESTAMP,        timeseries_moisture = site_swc.SWC_F_MDS_1,        start_dates = site_heatwaves['start_dates'],        end_dates = site_heatwaves['end_dates']        )        # Add heatwaves into a dictionary with their site    heatwaves_min[site] = site_heatwaves    heatwaves_min[site]['precip'] = site_heatwave_precip    heatwaves_min[site]['swc'] = site_heatwave_swc    # Create a dataframe of the quality flag for each heatwave at each siteheatwaves_qaqc = pd.DataFrame(columns=['start_dates','end_dates','duration','magnitude','QAQC_flag'])for site in list(heatwaves_min.keys()):    print(site)    # Retrieve the heatwave dictionary for that site    site_heatwave_dictionary = heatwaves_min[site]    dates = ta_HH[ta_HH['Site']==site].TIMESTAMP_START    TA = ta_HH[ta_HH['Site']==site].TA_F    TA_QAQC = ta_HH[ta_HH['Site']==site].TA_F_QC    # Use function to find if heatwaves have sufficient levels of ERA dowscaled data    site_check = minmax_QAQC_check(site_heatwave_dictionary, dates, TA, TA_QAQC, heatwave_threshold = .75, method='min')    # Add the site onto this dataframe    site_check['Site'] = [site] * site_check.shape[0]    # Concat with the other site dataframes    heatwaves_qaqc = pd.concat([heatwaves_qaqc,site_check])    # Find those invalid heatwavesinvalid_heatwaves_min = heatwaves_qaqc[heatwaves_qaqc['QAQC_flag']==1]invalid_heatwaves_min = invalid_heatwaves_min[['Site','start_dates','end_dates']]invalid_heatwaves_min.columns = ['Site','start_date','end_date']# Now remove these heatwavesheatwaves_min = remove_invalid_heatwaves(heatwaves_dictionary = heatwaves_min, invalid_heatwaves = invalid_heatwaves)# Create a dataframe of all precip conditionsall_precip_min = pd.DataFrame(columns=['start_date','end_date','moisture_average','moisture_total','Site','Duration'])for site in heatwaves_min.keys():    # Pull out moisture for the site    site_data = heatwaves_min[site]['precip']    # Add a site column    site_data['Site'] = [site]*len(site_data)    site_data['Duration'] = heatwaves_min[site]['summary'].duration    # Concat site data with all other data    all_precip_min = pd.concat([all_precip_min,site_data])    # Same for all SWC conditionsall_swc_min = pd.DataFrame(columns=['start_date','end_date','moisture_average','moisture_total','Site'])for site in heatwaves_min.keys():    # Pull out moisture for the site    site_data = heatwaves_min[site]['swc']    # Add a site column    site_data['Site'] = [site]*len(site_data)    # Concat site data with all other data    all_swc_min = pd.concat([all_swc_min,site_data])all_swc_min = all_swc_min.dropna()# Save the dictionary as a pickleos.chdir("/Users/marleeyork/Documents/project2/data/heatwaves/")with open("heatwaves_min.pkl","wb") as f:    pickle.dump(heatwaves_min, f)# Save moisture data as a csvall_precip_min.to_csv("min_precip.csv")all_swc_min.to_csv("min_swc.csv")# Save invalid heatwave dataframe as a csvinvalid_heatwaves_min.to_csv("invalid_heatwaves_min.csv")#################################################################################                         Combining the heatwaves                           ################################################################################## Looking at sites where a large percentage of heatwaves that are invalidinvalid_sites = set(list(invalid_sites_max) + list(invalid_sites_min) + list(invalid_sites_mean))# Calculate the heatwave overlapall_heatwaves = find_heatwave_overlap(min_heatwaves = heatwaves_min,                      max_heatwaves = heatwaves,                      avg_heatwaves = heatwaves_mean                      )# Now I am going to remove those sites with too many invalid heatwavesall_heatwaves = {k: v for k, v in all_heatwaves.items() if k not in invalid_sites}# Save the dictionary as a pickleos.chdir("/Users/marleeyork/Documents/project2/data/heatwaves/")with open("all_heatwaves.pkl","wb") as f:    pickle.dump(all_heatwaves, f)# Unpacking all heatwaves and organizing into dataframe by site# Initialize a dataframe to store heatwavesall_heatwaves_df = pd.DataFrame(columns=['Site','start_dates','end_dates','top_heatwave'])# Loop through each sitefor site in list(all_heatwaves.keys()):    # Pull the sites heatwaves from the dictionary of overlapping heatwaves    this_site_heatwaves = all_heatwaves[site]['heatwave_type']    # Add a site column    this_site_heatwaves['Site'] = [site] * this_site_heatwaves.shape[0]    # Concat with the other sites dataframe    all_heatwaves_df = pd.concat([all_heatwaves_df, this_site_heatwaves])    # Merge with IGBP (loaded this in the moisture section)all_heatwaves_df = pd.merge(all_heatwaves_df,IGBP,on='Site',how='inner').drop_duplicates()# Isolate the month from the start dateall_heatwaves_df['Month'] = all_heatwaves_df['start_dates'].dt.month# Create a season variable from the monthseason = []for i in range(all_heatwaves_df.shape[0]):    month = all_heatwaves_df.iloc[i]['Month']    if (3 <= month <= 5):        season.append('Spring')    elif (6 <= month <= 8):        season.append('Summer')    elif (9 <= month <= 11):        season.append('Fall')    else:        season.append('Winter')all_heatwaves_df['Season'] = season# Find the swc data for each siteall_moisture = pd.DataFrame(columns=['Site','start_dates','end_dates',                                     'prec_average','prec_total','prec_variability',                                     'swc_average','swc_total','swc_variability'])for site in all_heatwaves.keys():    # Pull the swc, prec, and heatwave data for the site    site_swc = swc_data[swc_data['Site']==site]    site_prec = prec_data[prec_data['Site']==site]    site_heatwaves = all_heatwaves_df[all_heatwaves_df['Site']==site]    # Calculate the swc values and replace any less than 0 with NA    heatwave_swc = calculate_moisture(timeseries_dates=site_swc.TIMESTAMP,                                      timeseries_moisture=site_swc.SWC_F_MDS_1,                                      start_dates=site_heatwaves.start_dates,                                      end_dates=site_heatwaves.end_dates)    heatwave_swc.columns = ['start_dates','end_dates','swc_average','swc_total','swc_variability']    mask = heatwave_swc['swc_total'] < 0    heatwave_swc.loc[mask, ['swc_average', 'swc_total', 'swc_variability']] = np.nan    # Doing the same for precipitation data now    heatwave_prec = calculate_moisture(timeseries_dates=site_prec.TIMESTAMP,                                       timeseries_moisture=site_prec.P_F,                                       start_dates=site_heatwaves.start_dates,                                       end_dates=site_heatwaves.end_dates)    heatwave_prec.columns = ['start_dates','end_dates','prec_average','prec_total','prec_variability']    mask = heatwave_prec['prec_total'] < 0    heatwave_prec.loc[mask, ['prec_average','prec_total','prec_variability']] = np.nan    # Merge swc and prec data together    site_heatwave_moisture = pd.merge(heatwave_prec,heatwave_swc,on=['start_dates','end_dates'],how='inner')    site_heatwave_moisture['Site'] = [site] * len(site_heatwave_moisture)    # Concat site data with other sites    all_moisture = pd.concat([all_moisture,site_heatwave_moisture])# Merge with the rest of the heatwave dataall_heatwaves_df = pd.merge(all_heatwaves_df, all_moisture, on=['Site','start_dates','end_dates'],how='left')# Adding in a heatwave duration columnall_heatwaves_df['duration'] = all_heatwaves_df.end_dates - all_heatwaves_df.start_dates   all_heatwaves_df['duration'] = all_heatwaves_df['duration'].dt.days + 1# Drop anything less than 3 days (there should be none)all_heatwaves_df = all_heatwaves_df[all_heatwaves_df['duration'] > 2]# Write this to a csvall_heatwaves_df.to_csv("/Users/marleeyork/Documents/project2/data/heatwaves/all_heatwaves_df.csv")#################################################################################                                Pezza                                      #################################################################################'''The code below implements the Pezza 2012 heatwave defining approach. This approachuses a 3 day running maximum and minimum temperature threshold to determine heatwaves. ''''''# Need to load in minimum and maximum historical temperatures# Load climatological datahistorical_data_max = pd.read_csv('/Users/marleeyork/Documents/project2/data/PRISM/extracted_daily_climate_data_wide_tmax.csv')historical_data_max.date = pd.to_datetime(historical_data_max.date)historical_data_min = pd.read_csv('/Users/marleeyork/Documents/project2/data/PRISM/extracted_daily_tmin_data_wide.csv')# Initialize empty dictionaryheatwaves_Pezza = {}for site in AMF_data.Site.unique():    flux_data = AMF_data[AMF_data['Site']==site]    # Isolate site of interest in climatological and AMF data    # historical_temp_max = historical_data_max[['date',site]]    # historical_temp_min = historical_data_min[['date',site]]    tmax = find_max_temperatures(flux_data.TIMESTAMP_START, flux_data.TA_F) # remove this when you get historical data    tmin = find_min_temperatures(flux_data.TIMESTAMP_START, flux_data.TA_F) # remove this wehn you get historical data    site_precip = prec_data[prec_data['Site']==site]    site_swc = swc_data[swc_data['Site']==site]        print(f"I'm currently on site {site}.")    # Fit the heatwave defining function    site_heatwaves = fit_Pezza_heatwaves(        flux_dates = flux_data.TIMESTAMP_START,         flux_temperature = flux_data.TA_F,         # historical_dates = historical_data_max.date,         # historical_temperature_max = historical_temp_max[site],        # historical_temperature_min = historical_temp_min[site],        # remove when you get historical data        historical_temperature_max = tmax.max_temperature, # remove when you get historical data        historical_temperature_min = tmin.min_temperature, # remove when you get historical data        historical_dates = tmax.date,        min_heatwave_length = 5,        tolerance=1,        gap_day_window=8,        site = site        )        # Getting precipitation conditions    site_heatwave_precip = calculate_moisture(        timeseries_dates = site_precip.TIMESTAMP,        timeseries_moisture = site_precip.P_F,        start_dates = site_heatwaves['start_dates'],        end_dates = site_heatwaves['end_dates']        )        site_heatwave_swc = calculate_moisture(        timeseries_dates = site_swc.TIMESTAMP,        timeseries_moisture = site_swc.SWC,        start_dates = site_heatwaves['start_dates'],        end_dates = site_heatwaves['end_dates']        )        # Add heatwaves into a dictionary with their site    heatwaves_Pezza[site] = site_heatwaves    heatwaves_Pezza[site]['precip'] = site_heatwave_precip    heatwaves_Pezza[site]['swc'] = site_heatwave_swc# Create a dataframe of all precip conditionsall_precip_Pezza = pd.DataFrame(columns=['start_date','end_date','moisture_average','moisture_total','Site','Duration'])for site in AMF_data.Site.unique():    # Pull out moisture for the site    site_data = heatwaves_Pezza[site]['precip']    # Add a site column    site_data['Site'] = [site]*len(site_data)    site_data['Duration'] = heatwaves_Pezza[site]['summary'].duration    # Concat site data with all other data    all_precip_Pezza = pd.concat([all_precip_Pezza,site_data])    # Same for all SWC conditionsall_swc_Pezza = pd.DataFrame(columns=['start_date','end_date','moisture_average','moisture_total','Site'])for site in AMF_data.Site.unique():    # Pull out moisture for the site    site_data = heatwaves_Pezza[site]['swc']    # Add a site column    site_data['Site'] = [site]*len(site_data)    # Concat site data with all other data    all_swc_Pezza = pd.concat([all_swc_Pezza,site_data])all_swc_Pezza = all_swc_Pezza.dropna()    '''