# This script will explore the different approaches for the definition of heatwaves# Importing packagesimport osimport pandas as pdimport numpy as npfrom matplotlib import pyplot as plt# Settings# Setting all columns to be printedpd.set_option('display.max_columns', None)# Import data: starting with US-Whs siteflux_data_Whs = pd.read_csv('/Users/marleeyork/Documents/project2/data/AMF_US-Whs_FLUXNET_SUBSET_HH_2007-2020_3-5.csv')historical_data = pd.read_csv('/Users/marleeyork/Documents/project2/data/extracted_daily_climate_data_wide_tmax.csv')historical_data_Whs = historical_data.loc[:,['date','US-Whs']]historical_data_Whs = historical_data_Whs.rename(columns={"date":"date", "US-Whs":"Tmax"})print(flux_data_Whs.head())print(historical_data_Whs.head())# DATA EXPLORATION ############################################################# Checking to see if I am working with continuous data: data is continuous# Convert to datetime just to be safeflux_data_Whs['timestamp'] = pd.to_datetime(flux_data_Whs['TIMESTAMP_START'], format='%Y%m%d%H%M')historical_data_Whs['date'] = pd.to_datetime(historical_data_Whs['date'], format='%Y-%m-%d')# Set as indexflux_data_Whs = flux_data_Whs.set_index('timestamp')# Generate the full expected range of datesfull_range = pd.date_range(start=flux_data_Whs.index.min(), end=flux_data_Whs.index.max(), freq='H')# Compare the expected range to what we havemissing = full_range.difference(flux_data_Whs.index)if len(missing) == 0:    print("All timestamps are continuous.")else:    print(f"⚠️ Missing {len(missing)} timestamps:")    print(missing)# Checking for any missing temperature values: None missingflux_data_Whs.isna().sum()# FUNCTIONS #################################################################### Name: find_min_temperatures() & find_max_temperatures()# Summary: These functions aggregates subdaily values of temperature (or any other#          variable) and calculates the maximum/minimum for each day# Input: date_vector ~ Datetime stamp with at a subdaily level (e.g., hourly or 30 minute)#        temperature_vector ~ Temperatures associated with date_vector# Output: (min/max)_temperatures ~ Pandas dataframe with column 'date' specifying#         daily dates and (max/min)_temperature specifying the summary statistic#         for that daydef find_max_temperatures(date_vector, temperature_vector):    # Create dataframe of timestamp and subdaily temperature    temp_df = pd.DataFrame({'timestamp': date_vector,                            'temperature': temperature_vector})        # Perform daily aggregation, calculate max, reogranize into new dataframe    max_temperatures = (    temp_df    .groupby(temp_df['timestamp'].dt.date)['temperature']    .max()    .reset_index()    .rename(columns={'timestamp': 'date', 'temperature': 'max_temperature'})    )           # Reset the date to a datetime variable    max_temperatures['date'] = pd.to_datetime(max_temperatures['date'])        return max_temperaturesdef find_min_temperatures(date_vector, temperature_vector):    # Create a dataframe of timestamp and subdaily temperature    temp_df = pd.DataFrame({'timestamp': date_vector,                            'temperature': temperature_vector})        # Perform daily aggregation, calculate max, reorganize into new dataframe    min_temperatures = (    temp_df    .groupby(temp_df['timestamp'].dt.date)['temperature']    .min()    .reset_index()    .rename(columns={'timestamp': 'date', 'temperature': 'min_temperature'})    )           # Reset the date to a datetime variable    min_temperatures['date'] = pd.to_datetime(min_temperatures['date'])        return min_temperatures# Example of the find_max_temperatures() and find_min_temperatures()max_temperatures_Whs = find_max_temperatures(flux_data_Whs.index, flux_data_Whs.TA_F)min_temperatures_Whs = find_min_temperatures(flux_data_Whs.index, flux_data_Whs.TA_F)plt.figure()plt.scatter(max_temperatures_Whs.date, max_temperatures_Whs.max_temperature, color= 'red', s = .5)plt.scatter(min_temperatures_Whs.date, min_temperatures_Whs.min_temperature, color = 'blue', s = .5)plt.show()# Name: moving_window_quantiles()# Summary: For a given length of moving window, calculate a quantile for#          across all historical values of a given measure (e.g., temperature, #          max temperatures, etc) for each day of the year. Each day's quantile#          will be based on a surrounding window, such that the day is the centre#          of the window being calculated.# Input: window_length ~ an odd number of days you want the window length to be#        dates ~ daily dates of historical data as datetime variable#        measure ~ daily measure associated with each day of dates#        quantile ~ quantile you want to calculate over the window (e.g., 90th)# Output: window_quantiles ~ dataframe with 'day' as a datetime variable specifying#         month and day, and 'quantile' specifying the quantile of interest for #         that day over the surrounding window.def moving_window_quantile(dates, measure, measure_quantile, window_length):    # Create dataframe of dates and measure    measure_df = pd.DataFrame({'date': dates,                               'month_day': dates.dt.strftime('%m-%d'),                               'measure': measure})        # Create range of all month and days throughout one year    window_centre = pd.date_range(start = '1800-01-01', end = '1800-12-31', freq = 'D')        # Determine the length of days backwards and forwards we need to look    # so that our day of interest is at the centre of our window    half_window_length = int((window_length - 1) / 2)        # Subtract and add half_window_length from date to determine start and end    # points of the window.    window_start = window_centre - pd.to_timedelta(half_window_length, unit='d')    window_end = window_centre + pd.to_timedelta(half_window_length, unit = 'd')        # Calculate the quantiles in each window    # Loop through the centre, start, and end of the windows    window_quantile = []    for centre, start, end in zip(window_centre, window_start, window_end):        # Create a range of M-D inside the window        window_range = pd.date_range(start=start, end=end, freq='D')                # Isolate the month and day for the window range        window_range = window_range.strftime('%m-%d')                # Create indicator for days from 'dates' that fall into the window range        window_mask = measure_df.month_day.isin(window_range)                # Calculate the quantiles for the measure over all days that fall in the window        window_quantile.append(measure_df[window_mask].measure.quantile(measure_quantile))            # Create dataframe of the month-day and the associated quantile    window_quantiles = pd.DataFrame({'month_day': window_centre.strftime('%m-%d'),                                    'quantile': window_quantile})        return window_quantiles# An example of the moving_window_quantiles() function, taking in US-Whs historical dates # and daily maximum temperature and calculating the 90th percentile within a 15 day window.max_temperature_90th_quantiles = moving_window_quantile(    dates = historical_data_Whs.date,     measure = historical_data_Whs.Tmax,     measure_quantile = .9,    window_length = 15    )plt.scatter(max_temperature_90th_quantiles['month_day'], max_temperature_90th_quantiles['quantile'])plt.show()    # Name: define_hotdays()# Summary: Returns an indicator (0/1) whether each day is a hot day or not based on#          whether is greater than, less than, or equal to some daily threshold (e.g.,#          90th quantile of maximum temperature or EHF value)    # Input: timeseries_dates ~ dates associated with the timeseries we want to define as hot or not#        timeseries_temperature ~ temperatures associated with each day of the timeseries#        threshold ~ the daily threshold value, in order by month-day (01-01, ..., 12-31)#        comparison ~ value "greater", "less", or "equal" to threshold# Output: hotdays ~ indicator vector (0 or 1) of length timeseries that defines#                    each day is 1 = hot day, or 0 = not hot daydef define_hotdays(timeseries_dates, timeseries_temperature, threshold_month_day, threshold, comparison):    # Create separate timeseries and threshold dataframes    timeseries_df = pd.DataFrame({'date':timeseries_dates,                                  'month_day': timeseries_dates.dt.strftime("%m-%d"),                                  'temperature':timeseries_temperature})    threshold_df = pd.DataFrame({'month_day':threshold_month_day,                                 'threshold':threshold})        # Merge by month so we have the timeseries with its corresponding threshold    df = pd.merge(timeseries_df, threshold_df, on="month_day", how="left")        # Create a T/F mask for whether the value for a given day is hot    if (comparison == 'greater'):        threshold_mask = df.temperature > df.threshold    elif (comparison == "lesser"):        threshold_mask = df.temperature < df.threshold    elif (comparison == "equal"):        threshold_mask = df.temperature == df.threshold    else:        print("Not a valid comparison entry... enter greater, lesser, or equal")            # Create a hotdays vector that is 1/0 corresponding to T/F in a dataframe    hotdays = pd.DataFrame({'date':timeseries_dates,                            'hotday_indicator':threshold_mask.astype(int)})        return hotdays# Example of the define_hotdays() function, taking in historical flux Tmax temperatures# (found using find_max_temperatures()) and comparing them to a threshold of# the historical 90th quantile of Tmax over a 15 day window (using moving_window_quantiles())max_temperatures_Whs = find_max_temperatures(flux_data_Whs.index, flux_data_Whs.TA_F)max_temperature_90th_quantiles = moving_window_quantile(    dates = historical_data_Whs.date,     measure = historical_data_Whs.Tmax,     measure_quantile = .9,    window_length = 15    )hotdays_Whs = define_hotdays(    timeseries_dates = max_temperatures_Whs['date'],    timeseries_temperature = max_temperatures_Whs['max_temperature'],    threshold_month_day = max_temperature_90th_quantiles['month_day'],    threshold = max_temperature_90th_quantiles['quantile'],    comparison = "greater"    )print(hotdays_Whs)# Plotting the above examplehotdays = max_temperatures_Whs[hotdays_Whs.hotday_indicator==1]plt.figure()plt.scatter(max_temperatures_Whs.date, max_temperatures_Whs.max_temperature, s = .5)plt.scatter(hotdays.date, hotdays.max_temperature, color="red", s=.5)plt.show()# Name: find_consecutive_hotdays()# Summary: This finds periods of time with consecutive hot days for heatwave definition     # Input: dates ~ dates across the timeseries of interest#        hotdays ~ binary (0/1) indicator of hot day, received from define_hotdays()#        minimum_length ~ minimum number of contiguous hotdays to be considered heatwave# Output: start_dates ~ vector of dates that mark the beginning of heatwaves#         end_dates ~ vector of dates that mark the end of heatwavesdef find_consecutive_hotdays(dates, hotdays, minimum_length):    # Loop through hotdays    start_indices = []    end_indices = []    i = 0    # Loop through each day    while i < len(hotdays) - minimum_length + 1:        # If the previous day was a hotday, move forward to the next        if (i > 0):            if (hotdays[i-1] == 1):                i += 1                continue                days_forward = 0         # Assuming heatwave, set to True        while True:            # Iteratively move forward a day and check if its a hotday            # If it is a hot day...            if (hotdays[i+days_forward] == 1):                print("hotday" + str(days_forward))                # and its the minimum length hot day in a row, add i as                # the start index (heatwave has started)                if (days_forward == minimum_length):                    print("we have a heatwave! starting" + str(dates[i]))                    start_indices.append(i)                    # If we are in a heatwave, but tomorrow is not a hotday,                     # add the current day as the end index, set i to the next day, and leave the loop                if ((days_forward >= minimum_length) & (hotdays[i+days_forward+1] == 0)):                    print("heatwave ends at " + str(dates[i+days_forward]))                    end_indices.append(i+days_forward)                    break                # Move onto next day to see if heatwave continues                days_forward += 1                        # If its not a hot day, break and move to next day            else: break        # If its not a hot day, or the heatwave is over,         i += 1        start_dates = dates[start_indices]    end_dates = dates[end_indices]        return start_dates, end_dates                    # This is an example of the find_consecutive_hotdays() functionstart_dates, end_dates = find_consecutive_hotdays(dates = hotdays_Whs.date,                                                   hotdays = hotdays_Whs.hotday_indicator,                                                   minimum_length = 3                                                  )                print([start_dates,end_dates])# Name: describe_heatwaves()# Summary: Gives some indices and information about the heatwaves # Input: start_dates ~ vector of heatwave start dates#        end_dates ~ vector of heatwave end dates#        timeseries_dates ~ vector of dates from timeseries of temp#        timeseries_temperature ~ vector of max temperature for each day of timeseries# Output: start_dates ~ vector of dates that mark the beginning of heatwaves#         end_dates ~ vector of dates that mark the end of heatwaves#         duration ~ length of days heatwave lasted#         magnitude ~ heatwave magnitude index defined by Marengo (2025)def describe_heatwaves(start_dates, end_dates, timeseries_dates, timeseries_temperature):        return heatwave_df
